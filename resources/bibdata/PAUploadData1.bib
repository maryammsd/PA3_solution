@article{Chase1990,
   abstract = {Note: \{OCR\} errors may be found in this Reference List extracted from the full text article. \{ACM\} has opted to expose the complete List rather than only correct and linked references.},
   author = {David R. Chase and Mark Wegman and F. Kenneth Zadeck},
   doi = {10.1145/93542.93585},
   isbn = {0897913647},
   journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
   pages = {296-310},
   title = {Analysis of pointers and structures},
   volume = {20-22-June},
   year = {1990},
}
@article{Jones1979,
   abstract = {In [12] the authors introduced the concept of binding time optimization and presented a series of data flow analytic methods for determining some of the binding time characteristics of programs. In this paper we extend that work by providing methods for determining the class of shapes which an unbounded data object may assume during execution of a LISP-like program, and describe a number of uses to which that information may be put to improve storage allocation in compilers and interpreters for advanced programming languages.We are concerned chiefly with finding, for each program point and variable a finite description of a set of graphs which includes all the shapes of values the variable could assume at that point during the execution of a program. If this set is small or regular in structure, this information can be used to optimize the program's execution, mainly by use of more efficient storage allocation schemes.In the first part we show how to construct from a program without selective updating a tree grammar whose nonterminals generate the desired sets of graphs; in this case they will all be trees. The tree grammars are of a more general form than is usually studied [8, 19], so we show that they may be converted to the usual form. The resulting tree grammar could naturally be viewed as a recursive type definition [11] of the values the variables may assume. Further, standard algorithms may be employed to test for infiniteness, emptiness or linearity of the tree structure.In the second part selective updating is allowed, so an alternate semantics is introduced which more closely resembles traditional LISP implementations, and which is equivalent to the tree model for programs without selective updating. In this model data objects are directed graphs. We devise a finite approximation method which provides enough information to detect cell sharing and cyclic structures whenever they can possibly occur. This information can be used to recognize when the use of garbage collection or of reference counts may be avoided.The work reported in the second part of this paper extends that of Schwartz [17] and Cousot and Cousot [7]. They have developed methods for determining whether the values of two or more variables share cells, while we provide information on the detailed structure of what is shared. The ability to detect cycles is also new. It also extends the work of Kaplan [13], who distinguishes only binary relations among the variables of a program, does not handle cycles, and does not distinguish selectors (so that his analysis applies to nodes representing sets rather than ordered tuples).},
   author = {Neil D. Jones and Steven S. Muchnick},
   doi = {10.1145/567752.567776},
   issn = {07308566},
   issue = {January 1979},
   journal = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
   pages = {244-256},
   title = {Flow analysis and optimization of LISP-like structures},
   year = {1979},
}
@book{Hutchison1973,
   abstract = {This book fills this void by including a collection of representative articles, which gives an up-to-date and comprehensive snapshot of the Peer-to-Peer field. One of the main challenges that faces any book covering such a vast and relatively new territory is how to structure the material. This book resolves this conundrum by dividing the material into roughly three parts. The first part of the book covers the basics of Peer-to-Peer designs, un- structured and structured systems, and presents a variety of applications in- cluding e-mail, multicast, Grid computing, andWeb services. The book then goes beyond describing traditional systems, by discussing general aspects of the Peer-to-Peer systems, namely the self-organization nature of the Peer- to-Peer systems, and the all-important topic of evaluating these systems. In addition, the book illustrates the broad applicability of Peer-to-Peer by dis- cussing the impact of the Peer-to-Peer technologies in two computer-science areas, namely searching and information retrieval, and mobile computing. No Peer-to-Peer book would be complete without discussing the business model, accounting, and security. This book touches on these topics in the last part.},
   author = {David Hutchison and John C Mitchell},
   doi = {10.1016/0020-7101(78)90038-7},
   isbn = {9783642206290},
   issn = {03029743},
   issue = {3},
   journal = {Lecture Notes in Computer Science},
   keywords = {and j,edited by g,goos,hartmanis,j,science,ture notes in computer,van leeuwen},
   pages = {242-242},
   pmid = {4520227},
   title = {Lecture Notes in Computer Science},
   volume = {9},
   url = {http://www.mendeley.com/research/lecture-notes-computer-science-2/},
   year = {1973},
}